1. Что выведет программа? Объяснить вывод программы.

package main

import (
"fmt"
)

func main() {
a := [5]int{76, 77, 78, 79, 80}
var b []int = a[1:4]
fmt.Println(b)
}

Программа выведет [77 78 79], потому что она создает срез из элементов массива a с индексами 1, 2 и 3.

2. Что выведет программа? Объяснить вывод программы. Объяснить как работают
defer’ы и порядок их вызовов.

package main

import (
"fmt"
)

func test() (x int) {
defer func() {
x++
}()
x = 1
return
}
func anotherTest() int {
var x int
defer func() {
x++
}()
x = 1
return x
}
func main() {
fmt.Println(test())fmt.Println(anotherTest())
}

Программа выведет:

2
1

Объяснение:

   - В функции test(), переменная x устанавливается равной 1, затем вызывается defer, который 
   инкрементирует x, но эта инкрементация выполняется после выполнения оператора return. 
   Поэтому функция test() возвращает значение x, равное 1, но после этого выполняется defer, 
   увеличивая x до 2.
   - В функции anotherTest(), переменная x также устанавливается равной 1, затем вызывается defer, 
   который инкрементирует x, но так как оператор return не зависит от значения x, функция возвращает 
   исходное значение x, равное 1. Затем выполняется defer, но это не влияет на возвращаемое значение.

Таким образом, порядок вызова defer не влияет на значение, которое будет возвращено функцией, 
но может изменить состояние переменных после завершения функции.

3. Что выведет программа? Объяснить вывод программы. Объяснить внутреннее
устройство интерфейсов и их отличие от пустых интерфейсов.

package main

import (
"fmt"
"os"
)

func Foo() error {
var err *os.PathError = nil
return err
}

func main() {
err := Foo()
fmt.Println(err)
fmt.Println(err == nil)
}


Программа выведет следующее:

<nil>
false

Теперь давайте разберемся, почему это происходит:

1. Функция Foo возвращает значение типа error, которое инициализируется значением nil, которое является 
нулевым значением для указателя *os.PathError. Это означает, что err в функции Foo 
является указателем на nil.

2. Затем в функции main результат вызова функции Foo присваивается переменной err. В этой переменной 
будет содержаться указатель на nil, потому что Foo возвращает err, который был инициализирован 
значением nil.

3. Затем программа выводит значение переменной err с помощью fmt.Println(err), что приводит к 
выводу <nil>. Это означает, что переменная err содержит указатель на nil.

4. Затем программа проверяет, равен ли err nil, с помощью fmt.Println(err == nil). Здесь результат 
будет false, потому что err содержит указатель на nil, а не само значение nil. В Go, сравнение 
указателя на nil с nil возвращает false.

Что касается вопроса о внутреннем устройстве интерфейсов и их отличии от пустых интерфейсов:

    - Интерфейсы в Go представляют абстрактные типы данных, которые определяют набор методов, 
    которые должен реализовать конкретный тип, чтобы удовлетворить интерфейс.

    - Пустой интерфейс, также известный как interface{}, не имеет ни одного метода, и поэтому 
    удовлетворяется любым типом данных. Это позволяет передавать любые значения в функции, 
    которые ожидают аргументы типа interface{}.

    - Пустые интерфейсы могут содержать значения любого типа, включая пользовательские типы данных. 
    Они полезны в случаях, когда вы не знаете заранее, какой тип данных будет передан, и хотите, 
    чтобы функция или метод могли принимать аргументы разных типов.

    - Интерфейсы, которые определяют методы, предоставляют более строгую типизацию и позволяют 
    обеспечить, чтобы конкретный тип данных реализовал определенный набор методов. Это используется 
    для создания более обобщенного и гибкого кода, который может работать с разными типами данных, 
    удовлетворяющими интерфейсу.

4. Что выведет программа? Объяснить вывод программы.

package main

func main() {
ch := make(chan int)
go func() {
for i := 0; i < 10; i++ {
ch <- i
}
}()
for n := range ch {
println(n)
}
}

Программа выведет следующее:

0
1
2
3
4
5
6
7
8
9
fatal error: all goroutines are asleep - deadlock!

Теперь давайте разберемся, почему это происходит:

В данном примере у нас работаю параллельно 2 горутины, 1-я которая принимае значения из небуферизированного 
канала и 2-я которая отправляет. Синхронизация осуществляется с помощью данного канала без буфера. После 
того как все значения будут приняты, горутины уйдут в режим ожидания, так как канал не закрыт, 
соответственно мы получим сообщение - fatal error: all goroutines are asleep - deadlock!. Чтобы этого 
избежать мы можем добавить defer close(ch) в функцию горутины отправки.


5. Что выведет программа? Объяснить вывод программы.

package maintype 

customError struct {
msg string
}

func (e *customError) Error() string {
return e.msg
}

func test() *customError {
{
// do something
}
return nil
}

func main() {
var err error
err = test()
if err != nil {
println("error")
return
}
println("ok")
}

Программа выведет следующее:

error

Давайте разберемся, почему это происходит:

В данной программе создается пользовательская структура customError, которая удовлетворяет интерфейсу 
error, и функцию test(), которая возвращает указатель на nil типа *customError. Затем программа в 
функции main() объявляет переменную err типа error, присваивает ей результат вызова функции test(), 
и проверяет err.

Поскольку функция test() возвращает указатель на nil, переменная err будет содержать этот указатель 
на nil. Таким образом, при проверке if err != nil условие будет истинным, и программа выведет "error", 
так как указатель на nil он указывает на nil, но сам по себе не является nil.

6. Что выведет программа? Объяснить вывод программы. Рассказать про
внутреннее устройство слайсов и что происходит при передаче их в качестве
аргументов функции.

package main

import (
"fmt"
)

func main() {
var s = []string{"1", "2", "3"}
modifySlice(s)
fmt.Println(s)
}

func modifySlice(i []string) {i[0] = "3"
i = append(i, "4")
i[1] = "5"
i = append(i, "6")
}

Программа выведет следующее:

[3 2 3]

Давайте разберемся, почему это происходит:

В этой программе у нас есть функция modifySlice, которая принимает срез i и изменяет его. Срезы в Go 
представляют собой структуры данных, которые включают в себя три компонента: указатель на массив, 
длину и емкость. Когда мы передаем срез в функцию, передается копия самой структуры среза, но не его 
элементы. То есть, изменения внутри функции могут затронуть элементы среза, но не его длину и емкость.

Давайте разберемся, что происходит в функции modifySlice:

    i[0] = "3" изменяет первый элемент среза i на "3". Это изменение отразится и на срезе s, 
    так как они оба ссылаются на один и тот же массив данных.

    i = append(i, "4") добавляет новый элемент "4" в срез i. Однако, это не изменяет срез s, 
    так как после этой операции i ссылается на другой массив данных (из-за увеличения емкости).

    i[1] = "5" изменяет второй элемент среза i на "5". Это также не затрагивает срез s, 
    так как i ссылается на другой массив данных.

    i = append(i, "6") снова добавляет новый элемент "6" в срез i. Теперь i ссылается на другой 
    массив данных, и это не влияет на срез s.

Поэтому, после выполнения функции modifySlice, срез s все еще содержит "3" как первый элемент, так как 
он изменяется внутри функции, но второй элемент "2" не изменяется, потому что изменения в i не 
влияют на s, и последующие изменения в i также не влияют на s.

7. Что выведет программа? Объяснить вывод программы.

package main

import (
"fmt"
"math/rand"
"time"
)

func asChan(vs ...int) <-chan int {
c := make(chan int)
go func() {
for _, v := range vs {
c <- v
time.Sleep(time.Duration(rand.Intn(1000)) *
time.Millisecond)
}
close(c)
}()
return c
}

func merge(a, b <-chan int) <-chan int {
c := make(chan int)
go func() {
for {
select {
case v := <-a:
c <- v
case v := <-b:
c <- v
}
}
}()return c
}
func main() {
a := asChan(1, 3, 5, 7)
b := asChan(2, 4 ,6, 8)
c := merge(a, b )
for v := range c {
fmt.Println(v)
}
}

Программа выведет следующее:

1
2
3
4
5
6
7
8
0
0
и далее бесконечный вывод пустых значений типа int

Давайте разберемся, почему это происходит:

1. Программа создает два канала, a и b, и генерирует в них значения из заданных наборов 
(1, 3, 5, 7 для a и 2, 4, 6, 8 для b).

2. Затем программа запускает функцию merge, которая объединяет значения из каналов a и b в канал c.

3. Горутина, запущенная в функции merge, использует конструкцию select для выбора доступных значений 
из каналов a и b и отправляет их в канал c. Однако, она не закрывает канал c после завершения работы.

4. После того как все значения из каналов a и b были отправлены в канал c, программа продолжает 
выполнять цикл for v := range c. Но так как канал c не был закрыт, этот цикл будет бесконечно 
ждать новых значений в канале c.

5. После завершения работы горутин, которые генерируют значения в каналах a и b, и после того как 
все значения были считаны из канала c, цикл for v := range c ожидает новых значений и выводит 0, 
так как канал c остается открытым и пустым.